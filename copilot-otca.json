[
  {
    "question": "Which of the following best describes observability in a cloud-native system?",
    "options": {
      "A": "Collecting as much telemetry data as possible without interpretation",
      "B": "The ability to infer internal system state from external outputs",
      "C": "A metric-driven SLAs enforcement mechanism",
      "D": "A centralized logging platform"
    },
    "answer": "B"
  },
  {
    "question": "What are the three core telemetry signals defined by OpenTelemetry?",
    "options": {
      "A": "Traces, Metrics, Logs",
      "B": "Events, Alerts, Metrics",
      "C": "Logs, Alerts, Notifications",
      "D": "Traces, Notifications, Reports"
    },
    "answer": "A"
  },
  {
    "question": "Which telemetry signal is best suited for capturing system health over time?",
    "options": {
      "A": "Logs",
      "B": "Traces",
      "C": "Metrics",
      "D": "Events"
    },
    "answer": "C"
  },
  {
    "question": "Context propagation in distributed tracing refers to:",
    "options": {
      "A": "Storing trace data in a central database",
      "B": "Passing trace context across process and network boundaries",
      "C": "Aggregating metrics from multiple sources",
      "D": "Filtering irrelevant spans"
    },
    "answer": "B"
  },
  {
    "question": "A span in OpenTelemetry represents:",
    "options": {
      "A": "A single numerical value over time",
      "B": "A unit of work with a start and end time",
      "C": "A sequence of log lines",
      "D": "A notification event"
    },
    "answer": "B"
  },
  {
    "question": "Which practice helps reduce telemetry volume but still provides representative traces?",
    "options": {
      "A": "Full trace recording",
      "B": "Random log sampling",
      "C": "Trace sampling",
      "D": "Metric downsampling"
    },
    "answer": "C"
  },
  {
    "question": "Which of these is NOT a benefit of observability?",
    "options": {
      "A": "Faster root-cause analysis",
      "B": "Better error budgeting",
      "C": "Reduced need for instrumentation",
      "D": "Improved performance optimization"
    },
    "answer": "C"
  },
  {
    "question": "In the OpenTelemetry context, a Resource describes:",
    "options": {
      "A": "The memory footprint of a span",
      "B": "Attributes describing the entity producing telemetry",
      "C": "The network bandwidth of the application",
      "D": "The log retention policy"
    },
    "answer": "B"
  },
  {
    "question": "Which OpenTelemetry component is responsible for turning internal SDK calls into telemetry data export?",
    "options": {
      "A": "Instrumentation Library",
      "B": "Collector",
      "C": "Exporter",
      "D": "Sampler"
    },
    "answer": "C"
  },
  {
    "question": "What is the primary role of semantic conventions in OpenTelemetry?",
    "options": {
      "A": "To enforce strict data schema compliance",
      "B": "To standardize attribute names and values",
      "C": "To limit the number of telemetry signals",
      "D": "To configure service mesh integrations"
    },
    "answer": "B"
  },
  {
    "question": "Which signal type in OpenTelemetry would you use to record HTTP request durations?",
    "options": {
      "A": "Logs",
      "B": "Metrics",
      "C": "Traces",
      "D": "Events"
    },
    "answer": "B"
  },
  {
    "question": "When manually instrumenting code to create a span, which method is used to start it?",
    "options": {
      "A": "startMetric()",
      "B": "createExporter()",
      "C": "startSpan()",
      "D": "beginLog()"
    },
    "answer": "C"
  },
  {
    "question": "Which sampler would you choose to record every nth trace deterministically?",
    "options": {
      "A": "AlwaysOnSampler",
      "B": "ParentBasedSampler",
      "C": "TraceIdRatioBasedSampler",
      "D": "CountBasedSampler"
    },
    "answer": "C"
  },
  {
    "question": "The TracerProvider in OpenTelemetry SDK is responsible for:",
    "options": {
      "A": "Managing metric exporters",
      "B": "Providing Tracer instances for span creation",
      "C": "Collecting log entries",
      "D": "Handling health checks"
    },
    "answer": "B"
  },
  {
    "question": "Which OpenTelemetry interface defines methods for recording numerical measurements over time?",
    "options": {
      "A": "SpanProcessor",
      "B": "MetricReader",
      "C": "Meter",
      "D": "LogEmitter"
    },
    "answer": "C"
  },
  {
    "question": "Baggage in OpenTelemetry is used for:",
    "options": {
      "A": "Storing large binary payloads",
      "B": "Propagating user-defined key-value pairs across services",
      "C": "Tagging spans with status codes",
      "D": "Configuring collector pipelines"
    },
    "answer": "B"
  },
  {
    "question": "Which propagation format is the default in OpenTelemetry for distributed tracing?",
    "options": {
      "A": "AWS X-Ray",
      "B": "Jaeger",
      "C": "W3C TraceContext",
      "D": "B3"
    },
    "answer": "C"
  },
  {
    "question": "A SimpleSpanProcessor differs from a BatchSpanProcessor in that it:",
    "options": {
      "A": "Always exports spans synchronously",
      "B": "Exports spans in batches",
      "C": "Filters out error spans",
      "D": "Only handles metrics"
    },
    "answer": "A"
  },
  {
    "question": "Which OpenTelemetry component applies transformations or actions on spans before they are exported?",
    "options": {
      "A": "Exporter",
      "B": "SpanProcessor",
      "C": "TracerProvider",
      "D": "Sampler"
    },
    "answer": "B"
  },
  {
    "question": "How do you record an exception within a span using the OpenTelemetry API?",
    "options": {
      "A": "span.recordException()",
      "B": "span.logError()",
      "C": "span.addLog()",
      "D": "span.emitError()"
    },
    "answer": "A"
  },
  {
    "question": "Which metric instrument would you use to measure the distribution of request sizes?",
    "options": {
      "A": "Counter",
      "B": "Histogram",
      "C": "Gauge",
      "D": "ObservableCounter"
    },
    "answer": "B"
  },
  {
    "question": "The default status code of a newly created span is:",
    "options": {
      "A": "ERROR",
      "B": "UNSET",
      "C": "OK",
      "D": "UNKNOWN"
    },
    "answer": "B"
  },
  {
    "question": "In the OpenTelemetry SDK, which class do you configure to set up exporters, processors, and resource attributes for tracing?",
    "options": {
      "A": "SdkMeterProvider",
      "B": "SdkTracerProvider",
      "C": "TelemetryConfiguration",
      "D": "GlobalOpenTelemetry"
    },
    "answer": "B"
  },
  {
    "question": "Which option correctly initializes OpenTelemetry’s global tracer in code?",
    "options": {
      "A": "OpenTelemetry.setTracerProvider(...)",
      "B": "GlobalOpenTelemetry.initializeTracer(...)",
      "C": "OpenTelemetrySdk.builder().buildAndRegisterGlobal()",
      "D": "Telemetry.registerGlobalTracer(...)"
    },
    "answer": "C"
  },
  {
    "question": "What does the OTLP exporter in OpenTelemetry do?",
    "options": {
      "A": "Exports telemetry via gRPC or HTTP in OpenTelemetry Protocol",
      "B": "Logs telemetry data to the console",
      "C": "Sends metrics to Prometheus only",
      "D": "Converts metrics into traces"
    },
    "answer": "A"
  },
  {
    "question": "Which OpenTelemetry concept allows grouping instrumentation libraries for processing rules?",
    "options": {
      "A": "Instrumentation Scope",
      "B": "Resource Schema",
      "C": "Signal Registry",
      "D": "Processing Chain"
    },
    "answer": "A"
  },
  {
    "question": "To record a gauge metric via callback, you use:",
    "options": {
      "A": "meter.createCounter()",
      "B": "meter.createObservableGauge()",
      "C": "meter.registerValueRecorder()",
      "D": "meter.createHistogram()"
    },
    "answer": "B"
  },
  {
    "question": "Which attribute key is recommended by semantic conventions for HTTP method?",
    "options": {
      "A": "http.method",
      "B": "request.method",
      "C": "http.request",
      "D": "method.http"
    },
    "answer": "A"
  },
  {
    "question": "An instrumentation filter which excludes spans based on name uses which processor?",
    "options": {
      "A": "SamplingProcessor",
      "B": "AttributeProcessor",
      "C": "SpanFilter",
      "D": "MetricFilter"
    },
    "answer": "C"
  },
  {
    "question": "Which OpenTelemetry metric reader periodically collects metrics and exports them?",
    "options": {
      "A": "PeriodicExportingMetricReader",
      "B": "SimpleMetricReader",
      "C": "PullMetricReader",
      "D": "BatchMetricReader"
    },
    "answer": "A"
  },
  {
    "question": "Which context propagation library would you include to use B3 headers?",
    "options": {
      "A": "opentelemetry-context-b3",
      "B": "opentelemetry-instrumentation-http",
      "C": "opentelemetry-extension-baggage",
      "D": "opentelemetry-exporter-b3"
    },
    "answer": "A"
  },
  {
    "question": "What role does the ResourceDetector play in the SDK?",
    "options": {
      "A": "Identifies attributes of the hosting environment automatically",
      "B": "Processes spans for sampling",
      "C": "Exports metrics to external sinks",
      "D": "Handles context propagation"
    },
    "answer": "A"
  },
  {
    "question": "Which environment variable can set the OTLP endpoint URL?",
    "options": {
      "A": "OTEL_EXPORTER_OTLP_ENDPOINT",
      "B": "OTEL_COLLECTOR_URL",
      "C": "OTLP_SERVER_URI",
      "D": "OTEL_RECEIVER_URL"
    },
    "answer": "A"
  },
  {
    "question": "What is the main difference between auto-instrumentation and manual instrumentation?",
    "options": {
      "A": "Auto-instrumentation requires code changes, manual does not",
      "B": "Manual instrumentation injects exporters, auto uses defaults",
      "C": "Auto-instrumentation instruments supported libraries without code changes",
      "D": "Manual instrumentation only works in Python"
    },
    "answer": "C"
  },
  {
    "question": "Which API call retrieves the global TracerProvider?",
    "options": {
      "A": "OpenTelemetry.getGlobalTracerProvider()",
      "B": "GlobalOpenTelemetry.getTracerProvider()",
      "C": "OpenTelemetrySdk.getTracerRegistry()",
      "D": "TelemetrySdk.getGlobalTracer()"
    },
    "answer": "B"
  },
  {
    "question": "In OpenTelemetry, an InstrumentationLibraryInfo object contains:",
    "options": {
      "A": "Configuration for the Collector pipeline",
      "B": "Name and version of the instrumented library",
      "C": "Sample rate for traces",
      "D": "Resource attributes"
    },
    "answer": "B"
  },
  {
    "question": "Which exporter would you choose to expose metrics for Prometheus scraping?",
    "options": {
      "A": "PrometheusExporter",
      "B": "OTLPExporter",
      "C": "LoggingExporter",
      "D": "JaegerExporter"
    },
    "answer": "A"
  },
  {
    "question": "What is configured in a View in the OpenTelemetry metrics SDK?",
    "options": {
      "A": "Span sampling strategy",
      "B": "Attribute filters and aggregation for metrics",
      "C": "Context propagation formats",
      "D": "Log formatters"
    },
    "answer": "B"
  },
  {
    "question": "Which status code should you set on a span to indicate the operation failed?",
    "options": {
      "A": "CANCELLED",
      "B": "ERROR",
      "C": "UNSET",
      "D": "OK"
    },
    "answer": "B"
  },
  {
    "question": "What does the OpenTelemetry Collector’s service.pipelines section define?",
    "options": {
      "A": "Sequence of receivers, processors, exporters for each signal type",
      "B": "Health check endpoints",
      "C": "Global SDK configuration",
      "D": "Instrumentation libraries"
    },
    "answer": "A"
  },
  {
    "question": "Which Collector component pulls telemetry from an application?",
    "options": {
      "A": "Receiver",
      "B": "Processor",
      "C": "Exporter",
      "D": "Extension"
    },
    "answer": "A"
  },
  {
    "question": "In the Collector, the Batch processor is used to:",
    "options": {
      "A": "Aggregate spans into bigger spans",
      "B": "Buffer and batch telemetry before exporting",
      "C": "Filter out low-priority metrics",
      "D": "Perform health checks"
    },
    "answer": "B"
  },
  {
    "question": "To receive spans in Jaeger format, which Collector receiver do you enable?",
    "options": {
      "A": "otlp",
      "B": "jaeger",
      "C": "zipkin",
      "D": "prometheus"
    },
    "answer": "B"
  },
  {
    "question": "Which extension would you add to enable the Collector’s built-in health check server?",
    "options": {
      "A": "zpages",
      "B": "pprof",
      "C": "health_check",
      "D": "memory_limiter"
    },
    "answer": "C"
  },
  {
    "question": "What mode runs the Collector as a sidecar agent next to your application?",
    "options": {
      "A": "Gateway",
      "B": "Agent",
      "C": "Proxy",
      "D": "Standalone"
    },
    "answer": "B"
  },
  {
    "question": "Which processor can enforce attribute value constraints on spans in the Collector?",
    "options": {
      "A": "spanmetrics",
      "B": "attributes",
      "C": "sampling",
      "D": "filter"
    },
    "answer": "B"
  },
  {
    "question": "Remote sampling decisions in the Collector are enabled by which processor?",
    "options": {
      "A": "tail_sampling",
      "B": "probabilistic_sampler",
      "C": "batch",
      "D": "memory_limiter"
    },
    "answer": "A"
  },
  {
    "question": "Which exporter in the Collector sends telemetry to an OTLP endpoint?",
    "options": {
      "A": "logging",
      "B": "otlp",
      "C": "prometheus",
      "D": "jaeger"
    },
    "answer": "B"
  },
  {
    "question": "What is the purpose of the memory_limiter extension in the Collector?",
    "options": {
      "A": "Manage Collector memory usage to prevent OOM",
      "B": "Limit span memory size per span",
      "C": "Throttle incoming HTTP requests",
      "D": "Control the size of metric buffers"
    },
    "answer": "A"
  },
  {
    "question": "Which file is typically used to configure the Collector pipelines?",
    "options": {
      "A": "collector.conf",
      "B": "otel-config.yaml",
      "C": "config.yaml",
      "D": "collector.yaml"
    },
    "answer": "D"
  },
  {
    "question": "Which Collector extension provides in-process diagnostics via HTTP endpoints like /metrics and /healthz?",
    "options": {
      "A": "zpages",
      "B": "pprof",
      "C": "health_check",
      "D": "recovery"
    },
    "answer": "B"
  },
  {
    "question": "When a Collector pipeline isn’t exporting telemetry, the first log you check is usually:",
    "options": {
      "A": "Agent memory logs",
      "B": "Collector configuration load messages",
      "C": "Service discovery logs",
      "D": "Processor metrics"
    },
    "answer": "B"
  },
  {
    "question": "To debug missing context propagation, which OpenTelemetry feature can you enable?",
    "options": {
      "A": "OTLP exporter debug mode",
      "B": "W3C Baggage header tracing",
      "C": "zPages extension",
      "D": "Collector batch processor logs"
    },
    "answer": "C"
  },
  {
    "question": "If spans are not appearing in the backend, what is the most likely root cause?",
    "options": {
      "A": "Instrumentation libraries missing semantic conventions",
      "B": "Exporter endpoint misconfiguration",
      "C": "Incorrect span status code",
      "D": "High metric cardinality"
    },
    "answer": "B"
  },
  {
    "question": "Which Collector log level gives you the most detailed debugging information?",
    "options": {
      "A": "info",
      "B": "warn",
      "C": "debug",
      "D": "error"
    },
    "answer": "C"
  },
  {
    "question": "To validate your Collector configuration without running it, you can use:",
    "options": {
      "A": "collector --dry-run",
      "B": "otlp-validator",
      "C": "otelcol --config config.yaml --dry-run",
      "D": "collector-cli check-config"
    },
    "answer": "C"
  },
  {
    "question": "Which diagnostic page provides a live view of in-memory spans in the Collector?",
    "options": {
      "A": "/v1/metrics",
      "B": "/healthz",
      "C": "/debug/tracez",
      "D": "/diagnostics/spans"
    },
    "answer": "C"
  },
  {
    "question": "When troubleshooting missing metrics, you notice the Collector never scraped your application. Which component is misconfigured?",
    "options": {
      "A": "receiver.prometheus",
      "B": "processor.batch",
      "C": "exporter.otlp",
      "D": "extension.zpages"
    },
    "answer": "A"
  },{
    "question": "Which practice improves service-level insights by deriving metrics from existing logs?",
    "options": {
      "A": "Log sampling",
      "B": "Log-to-metric transformation",
      "C": "Metric federation",
      "D": "Distributed tracing"
    },
    "answer": "B"
  },
  {
    "question": "In observability, an \"indicator\" metric typically represents what?",
    "options": {
      "A": "A raw log entry",
      "B": "A composite metric derived from multiple sources",
      "C": "A binary event",
      "D": "A trace segment"
    },
    "answer": "B"
  },
  {
    "question": "Which characteristic is NOT one of the three pillars of observability?",
    "options": {
      "A": "Metrics",
      "B": "Logs",
      "C": "Health checks",
      "D": "Traces"
    },
    "answer": "C"
  },
  {
    "question": "To measure concurrent active sessions, which metric instrument would you use?",
    "options": {
      "A": "Histogram",
      "B": "Gauge",
      "C": "Counter",
      "D": "UpDownCounter"
    },
    "answer": "B"
  },
  {
    "question": "Which concept refers to correlating spans and logs based on shared trace IDs and timestamps?",
    "options": {
      "A": "Data federation",
      "B": "Cross-signal linking",
      "C": "Data merging",
      "D": "Signal filtering"
    },
    "answer": "B"
  },
  {
    "question": "How does high cardinality impact metric storage backends?",
    "options": {
      "A": "Improves query performance",
      "B": "Reduces storage needs",
      "C": "Causes high memory usage",
      "D": "Optimizes dashboard rendering"
    },
    "answer": "C"
  },
  {
    "question": "What is the primary difference between logs and events in observability?",
    "options": {
      "A": "Logs are structured, events are unstructured",
      "B": "Events represent discrete state changes, logs record continuous streams",
      "C": "Logs carry trace context, events do not",
      "D": "There is no difference"
    },
    "answer": "B"
  },
  {
    "question": "Distributed tracing primarily helps answer which question?",
    "options": {
      "A": "What is the disk usage of a host?",
      "B": "Which service call chain caused latency?",
      "C": "How many errors occurred per minute?",
      "D": "Which user is active?"
    },
    "answer": "B"
  },
  {
    "question": "Which signal type best helps understand CPU utilization over time?",
    "options": {
      "A": "Logs",
      "B": "Events",
      "C": "Metrics",
      "D": "Traces"
    },
    "answer": "C"
  },
  {
    "question": "In blue-green deployments, observability is used mainly to:",
    "options": {
      "A": "Automate container restarts",
      "B": "Compare performance and errors between environments",
      "C": "Encrypt data in transit",
      "D": "Generate user reports"
    },
    "answer": "B"
  },
  {
    "question": "Which SRE practice most closely relies on observability data?",
    "options": {
      "A": "Chaos engineering",
      "B": "Incident retrospectives",
      "C": "Capacity planning",
      "D": "All of the above"
    },
    "answer": "D"
  },
  {
    "question": "In the context of observability, which description best fits an \"event\" telemetry signal?",
    "options": {
      "A": "A continuous stream of log entries",
      "B": "A discrete state change at a specific point in time",
      "C": "A numerical value recorded over intervals",
      "D": "A chain of related spans"
    },
    "answer": "B"
  },
  {
    "question": "Which OpenTelemetry SDK component automatically enriches telemetry data with environment-specific attributes?",
    "options": {
      "A": "ResourceDetector",
      "B": "SpanProcessor",
      "C": "Exporter",
      "D": "Sampler"
    },
    "answer": "A"
  },
  {
    "question": "How do you assign a custom service.name resource attribute to all telemetry in the Java OpenTelemetry SDK?",
    "options": {
      "A": "Call tracer.setAttribute(\"service.name\", name)",
      "B": "Configure a Resource via SdkTracerProvider.builder().setResource(...)",
      "C": "Use a Meter to record the service.name",
      "D": "Specify it in the SpanProcessor configuration"
    },
    "answer": "B"
  },
  {
    "question": "Which metric instrument allows you to record values that can both increase and decrease, such as current memory usage?",
    "options": {
      "A": "Counter",
      "B": "UpDownCounter",
      "C": "Histogram",
      "D": "ObservableGauge"
    },
    "answer": "B"
  },
  {
    "question": "When using baggage in OpenTelemetry, which practice is recommended to avoid performance overhead?",
    "options": {
      "A": "Propagate large binary data items",
      "B": "Use baggage sparingly and limit item size",
      "C": "Attach baggage to every span by default",
      "D": "Encode baggage as base64 strings"
    },
    "answer": "B"
  },
  {
    "question": "Which environment variable controls the propagation formats used by the OpenTelemetry SDK?",
    "options": {
      "A": "OTEL_PROPAGATORS",
      "B": "OTEL_EXPORTER_OTLP_ENDPOINT",
      "C": "OTEL_SAMPLER_RATIO",
      "D": "OTEL_BAGGAGE_ITEMS"
    },
    "answer": "A"
  },
  {
    "question": "In the Collector’s configuration, which section defines the flow of telemetry from receivers through processors to exporters?",
    "options": {
      "A": "receivers",
      "B": "processors",
      "C": "exporters",
      "D": "service.pipelines"
    },
    "answer": "D"
  },
  {
    "question": "To drop spans matching a given attribute in the Collector, which processor should you configure?",
    "options": {
      "A": "sampling",
      "B": "spanmetrics",
      "C": "filter",
      "D": "tail_sampling"
    },
    "answer": "C"
  },
  {
    "question": "Which OpenTelemetry Collector deployment mode is used when running a central gateway for multiple clusters?",
    "options": {
      "A": "Agent",
      "B": "Gateway",
      "C": "Sidecar",
      "D": "Proxy"
    },
    "answer": "B"
  },
  {
    "question": "Which Collector extension exposes Go profiling endpoints under /debug/pprof?",
    "options": {
      "A": "zpages",
      "B": "health_check",
      "C": "pprof",
      "D": "memory_limiter"
    },
    "answer": "C"
  },
  {
    "question": "Which command validates your Collector configuration without starting the service?",
    "options": {
      "A": "otelcol validate-config",
      "B": "otelcol --dry-run",
      "C": "otelcol --config config.yaml --dry-run",
      "D": "collector-cli check-config"
    },
    "answer": "C"
  },
  {
    "question": "What log level provides the most detailed internal decision-making information in the Collector?",
    "options": {
      "A": "info",
      "B": "debug",
      "C": "trace",
      "D": "error"
    },
    "answer": "C"
  },
  {
    "question": "Which environment variable sets the verbosity of OpenTelemetry SDK logs?",
    "options": {
      "A": "OTEL_LOG_LEVEL",
      "B": "OTEL_LOG_SINK",
      "C": "OTEL_COLLECTOR_LOG",
      "D": "OTEL_SDK_LOG_LEVEL"
    },
    "answer": "A"
  },
  {
    "question": "Which Collector extension must be enabled to view live span data under /debug/tracez?",
    "options": {
      "A": "pprof",
      "B": "zpages",
      "C": "health_check",
      "D": "recovery"
    },
    "answer": "B"
  },
  {
    "question": "Which processor in the Collector makes sampling decisions after a span has ended to support tail-based sampling?",
    "options": {
      "A": "tail_sampling",
      "B": "probabilistic_sampler",
      "C": "batch",
      "D": "memory_limiter"
    },
    "answer": "A"
  },
  {
    "question": "Which principle distinguishes observability from traditional monitoring?",
    "options": {
      "A": "Observability relies exclusively on predefined dashboards",
      "B": "Observability lets you ask new questions of your telemetry without changing code",
      "C": "Monitoring covers only infrastructure metrics",
      "D": "Monitoring uses tracing, while observability uses logs"
    },
    "answer": "B"
  },
  {
    "question": "In OpenTelemetry, an attribute is considered high cardinality when it has:",
    "options": {
      "A": "More than 100 unique values per minute",
      "B": "Only boolean values",
      "C": "Exactly two possible values",
      "D": "No impact on backend storage"
    },
    "answer": "A"
  },
  {
    "question": "To correlate logs with traces in OpenTelemetry, you must include which field in your log record?",
    "options": {
      "A": "service.name",
      "B": "trace_id",
      "C": "span_status",
      "D": "log_severity"
    },
    "answer": "B"
  },
  {
    "question": "Which OpenTelemetry concept groups data by instrumentation library name and version?",
    "options": {
      "A": "Instrumentation Scope",
      "B": "Resource Schema",
      "C": "Signal Registry",
      "D": "SDK Listener"
    },
    "answer": "A"
  },
  {
    "question": "Which object in the OpenTelemetry SDK holds the name and version of the instrumented library?",
    "options": {
      "A": "LibraryMetadata",
      "B": "InstrumentationLibraryInfo",
      "C": "ResourceAccount",
      "D": "SignalDescriptor"
    },
    "answer": "B"
  },
  {
    "question": "You want to rename and drop attributes on a metric. Which SDK feature do you configure?",
    "options": {
      "A": "MetricReader",
      "B": "View",
      "C": "Exporter",
      "D": "Sampler"
    },
    "answer": "B"
  },
  {
    "question": "According to OpenTelemetry semantic conventions, which attribute key denotes the database system used?",
    "options": {
      "A": "db.vendor",
      "B": "db.system",
      "C": "sql.database",
      "D": "database.name"
    },
    "answer": "B"
  },
  {
    "question": "Which semantic convention attribute represents the remote network peer’s IP address?",
    "options": {
      "A": "network.peer.ip",
      "B": "net.peer.address",
      "C": "peer_ip",
      "D": "ip.remote"
    },
    "answer": "A"
  },
  {
    "question": "How do you disable HTTP auto-instrumentation via environment variable?",
    "options": {
      "A": "OTEL_HTTP_AUTOINSTRUMENTATION=false",
      "B": "OTEL_INSTRUMENTATION_HTTP_ENABLED=false",
      "C": "OTEL_EXPORTER_OTLP_DISABLED=true",
      "D": "OTEL_NO_INSTRUMENTATION=true"
    },
    "answer": "B"
  },
  {
    "question": "Which SDK component automatically adds host and deployment metadata to all telemetry?",
    "options": {
      "A": "ResourceDetector",
      "B": "SpanProcessor",
      "C": "BatchSpanProcessor",
      "D": "Sampler"
    },
    "answer": "A"
  },
  {
    "question": "In an OpenTelemetry Collector pipeline, which processor enforces or adds span attributes?",
    "options": {
      "A": "resource",
      "B": "attributes",
      "C": "batch",
      "D": "filter"
    },
    "answer": "B"
  },
  {
    "question": "What is the default port for the OTLP/gRPC receiver in the Collector?",
    "options": {
      "A": "55680",
      "B": "4317",
      "C": "4318",
      "D": "55679"
    },
    "answer": "B"
  },
  {
    "question": "Which Collector deployment mode runs as a sidecar alongside your application?",
    "options": {
      "A": "Gateway",
      "B": "Agent",
      "C": "Central",
      "D": "Proxy"
    },
    "answer": "B"
  },
  {
    "question": "To expose a health-check endpoint in the Collector, you must enable which extension?",
    "options": {
      "A": "zpages",
      "B": "pprof",
      "C": "health_check",
      "D": "recovery"
    },
    "answer": "C"
  },
  {
    "question": "Which Collector extension helps prevent out-of-memory by dropping data when usage nears a limit?",
    "options": {
      "A": "batch",
      "B": "memory_limiter",
      "C": "tail_sampling",
      "D": "queue"
    },
    "answer": "B"
  },
  {
    "question": "Which statement best describes the difference between monitoring and observability?",
    "options": {
      "A": "Monitoring and observability are interchangeable terms",
      "B": "Monitoring focuses on predefined alerts, observability lets you explore arbitrary telemetry without new code",
      "C": "Observability only uses logs, monitoring uses metrics",
      "D": "Monitoring requires no instrumentation, observability does"
    },
    "answer": "B"
  },
  {
    "question": "In the context of observability, a Service Level Indicator (SLI) is:",
    "options": {
      "A": "A target threshold for alerts",
      "B": "A numerical measure of system performance or reliability",
      "C": "The maximum allowed downtime per month",
      "D": "A binary up/down status"
    },
    "answer": "B"
  },
  {
    "question": "Which telemetry signal is most effective for capturing unstructured diagnostic messages?",
    "options": {
      "A": "Metrics",
      "B": "Traces",
      "C": "Logs",
      "D": "Events"
    },
    "answer": "C"
  },
  {
    "question": "Correlating logs, metrics, and traces primarily helps achieve:",
    "options": {
      "A": "Reduced telemetry storage costs",
      "B": "Faster root-cause analysis",
      "C": "Lower network bandwidth usage",
      "D": "Automated code instrumentation"
    },
    "answer": "B"
  },
  {
    "question": "Which method adds a custom event to an existing span using the OpenTelemetry API?",
    "options": {
      "A": "span.addEvent()",
      "B": "span.logEvent()",
      "C": "span.recordEvent()",
      "D": "span.emitEvent()"
    },
    "answer": "A"
  },
  {
    "question": "How do you set the status of a span to OK in OpenTelemetry code?",
    "options": {
      "A": "span.setStatus(\"OK\")",
      "B": "span.setStatus(StatusCode.OK)",
      "C": "span.ok()",
      "D": "span.markAsOk()"
    },
    "answer": "B"
  },
  {
    "question": "Which metric instrument should you use to record the current number of active sessions?",
    "options": {
      "A": "Counter",
      "B": "Histogram",
      "C": "Gauge",
      "D": "UpDownCounter"
    },
    "answer": "C"
  },
  {
    "question": "Which environment variable is used to configure the trace sampler type in the OpenTelemetry SDK?",
    "options": {
      "A": "OTEL_TRACES_SAMPLER",
      "B": "OTEL_PROPAGATORS",
      "C": "OTEL_EXPORTER_OTLP_ENDPOINT",
      "D": "OTEL_METRICS_EXPORTER"
    },
    "answer": "A"
  },
  {
    "question": "If you want to record every trace without sampling, you should use which sampler?",
    "options": {
      "A": "AlwaysOnSampler",
      "B": "AlwaysOffSampler",
      "C": "TraceIdRatioBasedSampler",
      "D": "ParentBasedSampler"
    },
    "answer": "A"
  },
  {
    "question": "Which instrument would you use to capture the distribution of request payload sizes?",
    "options": {
      "A": "ObservableGauge",
      "B": "Histogram",
      "C": "Counter",
      "D": "UpDownCounter"
    },
    "answer": "B"
  },
  {
    "question": "To create a new span manually, which API call do you use?",
    "options": {
      "A": "tracer.startSpan(\"operationName\")",
      "B": "tracer.spanBuilder(\"operationName\").startSpan()",
      "C": "tracer.createSpan(\"operationName\")",
      "D": "tracer.newSpan(\"operationName\")"
    },
    "answer": "B"
  },
  {
    "question": "Which SpanProcessor exports spans asynchronously in batches?",
    "options": {
      "A": "SimpleSpanProcessor",
      "B": "BatchSpanProcessor",
      "C": "SamplingSpanProcessor",
      "D": "ExportingSpanProcessor"
    },
    "answer": "B"
  },
  {
    "question": "In the Collector configuration file, under which top-level section do you declare extensions like memory_limiter and pprof?",
    "options": {
      "A": "receivers",
      "B": "extensions",
      "C": "processors",
      "D": "exporters"
    },
    "answer": "B"
  },
  {
    "question": "What is the default port for the Zipkin receiver in the OpenTelemetry Collector?",
    "options": {
      "A": "4317",
      "B": "4318",
      "C": "9411",
      "D": "14250"
    },
    "answer": "C"
  },
  {
    "question": "To scrape Prometheus metrics from an application in the Collector, you must configure which receiver?",
    "options": {
      "A": "otlpreceiver",
      "B": "zipkinreceiver",
      "C": "jaegerreceiver",
      "D": "prometheusreceiver"
    },
    "answer": "D"
  },
  {
    "question": "Which processor can attach or modify Resource attributes on incoming telemetry in the Collector?",
    "options": {
      "A": "attributes",
      "B": "resource",
      "C": "batch",
      "D": "filter"
    },
    "answer": "B"
  },
  {
    "question": "Which extension prevents Collector crashes by recovering from panics in pipeline components?",
    "options": {
      "A": "recovery",
      "B": "memory_limiter",
      "C": "health_check",
      "D": "zpages"
    },
    "answer": "A"
  },
  {
    "question": "What command would you run to validate a Collector configuration file without starting the service?",
    "options": {
      "A": "otelcol validate-config",
      "B": "otelcol --dry-run",
      "C": "otelcol --config config.yaml --dry-run",
      "D": "collector-cli check-config"
    },
    "answer": "C"
  },
  {
    "question": "Which extension provides in-process debug pages under /debug/tracez and /debug/metrics in the Collector?",
    "options": {
      "A": "pprof",
      "B": "zpages",
      "C": "health_check",
      "D": "memory_limiter"
    },
    "answer": "B"
  }
]
```

